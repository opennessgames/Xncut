<!--
 * @Author: xixi_
 * @Date: 2026-02-09 15:34:28
 * @LastEditors: xixi_
 * @LastEditTime: 2026-02-09 16:31:12
 * @FilePath: /Xncut-Design/Md/4.AvSync.md
 * Copyright (c) 2020-2026 by xixi_ , All Rights Reserved.
-->

# 音视频同步
> 这一块是重点, 又称音画同步, 我们以ffplay.c去分析如何去实现, 分析的版本是FFmpeg8.0.1

# 同步策略都有哪些?
ffplay.c有如下策略: 
```c
enum {
    AV_SYNC_AUDIO_MASTER, /* default choice */
    AV_SYNC_VIDEO_MASTER,
    AV_SYNC_EXTERNAL_CLOCK, /* synchronize to an external clock */
};
```
音频为主是ffplay.c默认的, 看注释也能看出来
- 音频为主, 现在音频是领导者, 视频要跟着音频的步伐
- 视频为主, 现在视频是领导者, 音频要跟着视频的步伐
- 外部时钟, 前两个组合起来, 突然蹦出个外来的, 音频和视频就是小弟, 听从外部时钟的指挥

# 废话
播放时间是恒定的, 单位是nFPS(也就是**N帧每秒**), 无论是24FPS, 还是30FPS, 需要在1秒内显示这些数量的图片, 帧率越大工作量就越大

1. 如果视频是60FPS, 48000Hz
2. 一帧图片就是1000ms / 60FPS = 16.67ms, 也就说1张图片会显示16.67ms
3. 48000 / 60 = 800, 也就说1帧图片就会播放800个点

# 时钟
实现音视频同步的关键, ffplay.c是这样定义的
```c
typedef struct Clock {
    double pts;           /* clock base */
    double pts_drift;     /* clock base minus time at which we updated the clock */
    double last_updated;
    double speed;
    int serial;           /* clock is based on a packet with this serial */
    int paused;
    int *queue_serial;    /* pointer to the current packet queue serial, used for obsolete clock detection */
} Clock;
```
- 然后我们全局搜索
![哪些地方有Clock结构体](Img/AvSync/1.png)
可以看到在VideoState的三处有Clock结构体
```c
Clock audclk; /* Audio clock的缩写 */
Clock vidclk; /* Video clock的缩写 */
Clock extclk; /* External clock的缩写 */
```
